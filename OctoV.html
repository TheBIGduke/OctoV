<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OctoV</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
        #status {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-size: 1.2em;
            color: #aaa;
            text-shadow: 0 0 5px #000;
            transition: opacity 1s ease-in-out;
        }
    </style>
</head>
<body>

    <p id="status">Requesting audio permissions...</p>

    <!-- Importmap for Three.js modules -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- DOM Elements ---
        const statusEl = document.getElementById('status');
        
        // --- Global Variables ---
        let scene, camera, renderer, composer, controls, sphere, clock, analyser, dataArray;
        
        // --- Initialization ---
        function init() {
            //API Logic
        window.addEventListener('sourceChange', (event) => {
            const source = event.detail.source;
            console.log(`API source changed to: ${source}`);

            if (source === 'USER') {
                sphere.material.uniforms.u_color.value.set(0xebbf34).multiplyScalar(1); // Orange
                sphere.material.uniforms.u_sensitivity.value = 0.1;
                sphere.scale.set(0.8, 0.8, 0.8);
                controls.autoRotateSpeed = 7.0;
            } else if (source === 'TTS') {
                sphere.material.uniforms.u_color.value.set(0x00ddff).multiplyScalar(1.2); // Blue
                sphere.material.uniforms.u_sensitivity.value = 0.20;
                sphere.scale.set(1.0, 1.0, 1.0);
                controls.autoRotateSpeed = 0.5;
            }
        });

            // Scene setup
            scene = new THREE.Scene();
            clock = new THREE.Clock();

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 2.5;

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);
            
            // Orbit Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            const sphereGeometry = new THREE.IcosahedronGeometry(1, 10);
            
            const sphereMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    u_time: { value: 0.0 },
                    u_frequency: { value: 0.0 },
                    u_color: { value: new THREE.Color(0x00ddff).multiplyScalar(1.2) },
                    u_sensitivity: { value: 0.20}
                },
                vertexShader: `
                    uniform float u_time;
                    uniform float u_frequency;
                    uniform float u_sensitivity;

                    // 3D Perlin Noise function (credit: Stefan Gustavson)
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                    float snoise(vec3 v) {
                        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                        vec3 i = floor(v + dot(v, C.yyy));
                        vec3 x0 = v - i + dot(i, C.xxx);
                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min(g.xyz, l.zxy);
                        vec3 i2 = max(g.xyz, l.zxy);
                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy;
                        vec3 x3 = x0 - D.yyy;
                        i = mod289(i);
                        vec4 p = permute(permute(permute(
                            i.z + vec4(0.0, i1.z, i2.z, 1.0))
                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                        float n_ = 0.142857142857;
                        vec3 ns = n_ * D.wyz - D.xzx;
                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_);
                        vec4 x = x_ * ns.x + ns.yyyy;
                        vec4 y = y_ * ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);
                        vec4 b0 = vec4(x.xy, y.xy);
                        vec4 b1 = vec4(x.zw, y.zw);
                        vec4 s0 = floor(b0)*2.0 + 1.0;
                        vec4 s1 = floor(b1)*2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));
                        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                        vec3 p0 = vec3(a0.xy,h.x);
                        vec3 p1 = vec3(a0.zw,h.y);
                        vec3 p2 = vec3(a1.xy,h.z);
                        vec3 p3 = vec3(a1.zw,h.w);
                        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                        m = m * m;
                        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                    }

                    void main() {
                        // Divisor is reduced for higher sensitivity
                        float freq = u_frequency / 90.0; 
                        
                        float noise = snoise(position * (1.0 + freq * 0.8) + u_time * 0.1);
                        
                        float displacement = noise * freq * u_sensitivity; 

                        vec3 newPosition = position + normal * displacement;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 u_color;
                    void main() {
                        gl_FragColor = vec4(u_color, 1.0);
                    }
                `,
                wireframe: true
            });
            sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            scene.add(sphere);

            // Post-Processing
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.4;
            bloomPass.strength = 0.7;
            bloomPass.radius = 0.5;
            composer.addPass(bloomPass);
            
            const outputPass = new OutputPass();
            composer.addPass(outputPass);

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            if (sphere && sphere.material.uniforms.u_time) {
                 sphere.material.uniforms.u_time.value = clock.getElapsedTime();
            }

            if (analyser) {
                analyser.getByteFrequencyData(dataArray);
                
                let sum = dataArray.reduce((a, b) => a + b, 0);
                const average = sum / dataArray.length || 0;
                
                // Smoothing the audio data for a less jittery animation
                sphere.material.uniforms.u_frequency.value += (average - sphere.material.uniforms.u_frequency.value) * 0.10
            }

            composer.render();
        }

        async function setupAudio(deviceId) {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: { deviceId: { exact: deviceId } }
                });

                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 64;
                analyser.smoothingTimeConstant = 0.8;
                source.connect(analyser);

                dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                statusEl.textContent = 'Visualization running...';
                setTimeout(() => { statusEl.style.opacity = '0'; }, 2000);

            } catch (err) {
                console.error("Error setting up audio source:", err);
                statusEl.textContent = `Error: Could not start audio. ${err.message}`;
            }
        }
        
        async function autoStartVisualizer() {
            const TARGET_DEVICE_LABEL = 'Monitor of Built-in Audio Analog Stereo'; // Change this to your target device name

            try {
                // First, request generic permission to unblock device enumeration
                await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                statusEl.textContent = `Searching for audio device: "${TARGET_DEVICE_LABEL}"...`;

                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');
                
                const targetDevice = audioInputs.find(device => device.label.includes(TARGET_DEVICE_LABEL));
                
                if (targetDevice) {
                    statusEl.textContent = 'Device found. Starting visualization...';
                    await setupAudio(targetDevice.deviceId);
                } else {
                    console.warn(`Could not find device named "${TARGET_DEVICE_LABEL}". Available devices:`, audioInputs);
                    statusEl.innerHTML = `Error: Could not find audio device: "${TARGET_DEVICE_LABEL}". <br/> Check the console (F12) for a list of available devices.`;
                }
            } catch (err) {
                console.error('Error during auto-start:', err);
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    statusEl.textContent = 'Error: You must grant microphone permission.';
                } else {
                    statusEl.textContent = 'An error occurred while accessing audio devices.';
                }
            }
        }

        init();
        animate();
        autoStartVisualizer();

    </script>
</body>
</html>

